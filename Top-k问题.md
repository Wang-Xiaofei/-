---
UID: 2403062132
link: ""
cssclasses: 
tags:
  - 数据结构/堆
---

>问题：给定一个长度为 𝑛 的无序数组 `nums` ，请返回数组中最大的 𝑘 个元素。

三种方法求解：遍历选择、排序和堆。
- 遍历选择：只适用于 𝑘≪𝑛 的情况，时间复杂度为 𝑂(𝑛𝑘) 。
- 排序：时间复杂度为 𝑂(𝑛log⁡𝑛)
- 堆：

##### 方法一：遍历排序

我们可以进行图所示的 𝑘 轮遍历，分别在每轮中提取第 1、2、…、𝑘 大的元素，时间复杂度为 𝑂(𝑛𝑘) 。

此方法只适用于 𝑘≪𝑛 的情况，因为当 𝑘 与 𝑛 比较接近时，其时间复杂度趋向于 𝑂(𝑛2) ，非常耗时。

![[Top-k问题.md_Attachments/Top-k问题.png|700]]

当 𝑘=𝑛 时，我们可以得到完整的有序序列，此时等价于“选择排序”算法。

##### 方法二：排序

如图所示，我们可以先对数组 `nums` 进行排序，再返回最右边的 𝑘 个元素，时间复杂度为 𝑂(𝑛log⁡𝑛) 。

显然，该方法“超额”完成任务了，因为我们只需找出最大的 𝑘 个元素即可，而不需要排序其他元素。

![[Top-k问题.md_Attachments/Top-k问题-1.png]]


##### 方法三：堆

我们可以基于堆更加高效地解决 Top-k 问题，流程如图所示。

1. 初始化一个小顶堆，其堆顶元素最小。
2. 先将数组的前 𝑘 个元素依次入堆。
3. 从第 𝑘+1 个元素开始，若当前元素大于堆顶元素，则将堆顶元素出堆，并将当前元素入堆。
4. 遍历完成后，堆中保存的就是最大的 𝑘 个元素。


代码如下：

```cpp
/* 基于堆查找数组中最大的 k 个元素 */
priority_queue<int, vector<int>, greater<int>> topKHeap(vector<int> &nums, int k) {
    // 初始化小顶堆
    priority_queue<int, vector<int>, greater<int>> heap;
    // 将数组的前 k 个元素入堆
    for (int i = 0; i < k; i++) {
        heap.push(nums[i]);
    }
    // 从第 k+1 个元素开始，保持堆的长度为 k
    for (int i = k; i < nums.size(); i++) {
        // 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆
        if (nums[i] > heap.top()) {
            heap.pop();
            heap.push(nums[i]);
        }
    }
    return heap;
}
```

总共执行了 𝑛 轮入堆和出堆，堆的最大长度为 𝑘 ，因此时间复杂度为 𝑂(𝑛log⁡𝑘) 。该方法的效率很高，当 𝑘 较小时，时间复杂度趋向 𝑂(𝑛) ；当 𝑘 较大时，时间复杂度不会超过 𝑂(𝑛log⁡𝑛) 。

另外，该方法适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现最大的 𝑘 个元素的动态更新。




















